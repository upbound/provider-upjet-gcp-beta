// SPDX-FileCopyrightText: 2025 Upbound Inc. <https://upbound.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type BackendInitParameters struct {

	// Specifies the balancing mode for this backend.
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is UTILIZATION.
	// Possible values are: UTILIZATION, RATE, CONNECTION, CUSTOM_METRICS.
	BalancingMode *string `json:"balancingMode,omitempty" tf:"balancing_mode,omitempty"`

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// ~>NOTE: This field cannot be set for
	// INTERNAL region backend services (default loadBalancingScheme),
	// but is required for non-INTERNAL backend service. The total
	// capacity_scaler for all backends must be non-zero.
	// A setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	CapacityScaler *float64 `json:"capacityScaler,omitempty" tf:"capacity_scaler,omitempty"`

	// The set of custom metrics that are used for CUSTOM_METRICS BalancingMode.
	// Structure is documented below.
	CustomMetrics []CustomMetricsInitParameters `json:"customMetrics,omitempty" tf:"custom_metrics,omitempty"`

	// An optional description of this resource.
	// Provide this property when you create the resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// This field designates whether this is a failover backend. More
	// than one failover backend can be configured for a given RegionBackendService.
	Failover *bool `json:"failover,omitempty" tf:"failover,omitempty"`

	// The fully-qualified URL of an Instance Group or Network Endpoint
	// Group resource. In case of instance group this defines the list
	// of instances that serve traffic. Member virtual machine
	// instances from each instance group must live in the same zone as
	// the instance group itself. No two backends in a backend service
	// are allowed to use same Instance Group resource.
	// For Network Endpoint Groups this defines list of endpoints. All
	// endpoints of Network Endpoint Group must be hosted on instances
	// located in the same zone as the Network Endpoint Group.
	// Backend services cannot mix Instance Group and
	// Network Endpoint Group backends.
	// When the load_balancing_scheme is INTERNAL, only instance groups
	// are supported.
	// Note that you must specify an Instance Group or Network Endpoint
	// Group resource using the fully-qualified URL, rather than a
	// partial URL.
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// Cannot be set for INTERNAL backend services.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. Cannot be set
	// for INTERNAL backend services.
	// This is used to calculate the capacity of the group. Can be
	// used in either CONNECTION or UTILIZATION balancing modes. For
	// CONNECTION mode, either maxConnections or
	// maxConnectionsPerEndpoint must be set.
	MaxConnectionsPerEndpoint *float64 `json:"maxConnectionsPerEndpoint,omitempty" tf:"max_connections_per_endpoint,omitempty"`

	// The max number of simultaneous connections that a single
	// backend instance can handle. Cannot be set for INTERNAL backend
	// services.
	// This is used to calculate the capacity of the group.
	// Can be used in either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	MaxConnectionsPerInstance *float64 `json:"maxConnectionsPerInstance,omitempty" tf:"max_connections_per_instance,omitempty"`

	// The max requests per second (RPS) of the group. Cannot be set
	// for INTERNAL backend services.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. Either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	MaxRate *float64 `json:"maxRate,omitempty" tf:"max_rate,omitempty"`

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set. Cannot be set
	// for INTERNAL backend services.
	MaxRatePerEndpoint *float64 `json:"maxRatePerEndpoint,omitempty" tf:"max_rate_per_endpoint,omitempty"`

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set. Cannot be set
	// for INTERNAL backend services.
	MaxRatePerInstance *float64 `json:"maxRatePerInstance,omitempty" tf:"max_rate_per_instance,omitempty"`

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	// Cannot be set for INTERNAL backend services.
	MaxUtilization *float64 `json:"maxUtilization,omitempty" tf:"max_utilization,omitempty"`
}

type BackendObservation struct {

	// Specifies the balancing mode for this backend.
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is UTILIZATION.
	// Possible values are: UTILIZATION, RATE, CONNECTION, CUSTOM_METRICS.
	BalancingMode *string `json:"balancingMode,omitempty" tf:"balancing_mode,omitempty"`

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// ~>NOTE: This field cannot be set for
	// INTERNAL region backend services (default loadBalancingScheme),
	// but is required for non-INTERNAL backend service. The total
	// capacity_scaler for all backends must be non-zero.
	// A setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	CapacityScaler *float64 `json:"capacityScaler,omitempty" tf:"capacity_scaler,omitempty"`

	// The set of custom metrics that are used for CUSTOM_METRICS BalancingMode.
	// Structure is documented below.
	CustomMetrics []CustomMetricsObservation `json:"customMetrics,omitempty" tf:"custom_metrics,omitempty"`

	// An optional description of this resource.
	// Provide this property when you create the resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// This field designates whether this is a failover backend. More
	// than one failover backend can be configured for a given RegionBackendService.
	Failover *bool `json:"failover,omitempty" tf:"failover,omitempty"`

	// The fully-qualified URL of an Instance Group or Network Endpoint
	// Group resource. In case of instance group this defines the list
	// of instances that serve traffic. Member virtual machine
	// instances from each instance group must live in the same zone as
	// the instance group itself. No two backends in a backend service
	// are allowed to use same Instance Group resource.
	// For Network Endpoint Groups this defines list of endpoints. All
	// endpoints of Network Endpoint Group must be hosted on instances
	// located in the same zone as the Network Endpoint Group.
	// Backend services cannot mix Instance Group and
	// Network Endpoint Group backends.
	// When the load_balancing_scheme is INTERNAL, only instance groups
	// are supported.
	// Note that you must specify an Instance Group or Network Endpoint
	// Group resource using the fully-qualified URL, rather than a
	// partial URL.
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// Cannot be set for INTERNAL backend services.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. Cannot be set
	// for INTERNAL backend services.
	// This is used to calculate the capacity of the group. Can be
	// used in either CONNECTION or UTILIZATION balancing modes. For
	// CONNECTION mode, either maxConnections or
	// maxConnectionsPerEndpoint must be set.
	MaxConnectionsPerEndpoint *float64 `json:"maxConnectionsPerEndpoint,omitempty" tf:"max_connections_per_endpoint,omitempty"`

	// The max number of simultaneous connections that a single
	// backend instance can handle. Cannot be set for INTERNAL backend
	// services.
	// This is used to calculate the capacity of the group.
	// Can be used in either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	MaxConnectionsPerInstance *float64 `json:"maxConnectionsPerInstance,omitempty" tf:"max_connections_per_instance,omitempty"`

	// The max requests per second (RPS) of the group. Cannot be set
	// for INTERNAL backend services.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. Either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	MaxRate *float64 `json:"maxRate,omitempty" tf:"max_rate,omitempty"`

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set. Cannot be set
	// for INTERNAL backend services.
	MaxRatePerEndpoint *float64 `json:"maxRatePerEndpoint,omitempty" tf:"max_rate_per_endpoint,omitempty"`

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set. Cannot be set
	// for INTERNAL backend services.
	MaxRatePerInstance *float64 `json:"maxRatePerInstance,omitempty" tf:"max_rate_per_instance,omitempty"`

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	// Cannot be set for INTERNAL backend services.
	MaxUtilization *float64 `json:"maxUtilization,omitempty" tf:"max_utilization,omitempty"`
}

type BackendParameters struct {

	// Specifies the balancing mode for this backend.
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is UTILIZATION.
	// Possible values are: UTILIZATION, RATE, CONNECTION, CUSTOM_METRICS.
	// +kubebuilder:validation:Optional
	BalancingMode *string `json:"balancingMode,omitempty" tf:"balancing_mode,omitempty"`

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// ~>NOTE: This field cannot be set for
	// INTERNAL region backend services (default loadBalancingScheme),
	// but is required for non-INTERNAL backend service. The total
	// capacity_scaler for all backends must be non-zero.
	// A setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	// +kubebuilder:validation:Optional
	CapacityScaler *float64 `json:"capacityScaler,omitempty" tf:"capacity_scaler,omitempty"`

	// The set of custom metrics that are used for CUSTOM_METRICS BalancingMode.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CustomMetrics []CustomMetricsParameters `json:"customMetrics,omitempty" tf:"custom_metrics,omitempty"`

	// An optional description of this resource.
	// Provide this property when you create the resource.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// This field designates whether this is a failover backend. More
	// than one failover backend can be configured for a given RegionBackendService.
	// +kubebuilder:validation:Optional
	Failover *bool `json:"failover,omitempty" tf:"failover,omitempty"`

	// The fully-qualified URL of an Instance Group or Network Endpoint
	// Group resource. In case of instance group this defines the list
	// of instances that serve traffic. Member virtual machine
	// instances from each instance group must live in the same zone as
	// the instance group itself. No two backends in a backend service
	// are allowed to use same Instance Group resource.
	// For Network Endpoint Groups this defines list of endpoints. All
	// endpoints of Network Endpoint Group must be hosted on instances
	// located in the same zone as the Network Endpoint Group.
	// Backend services cannot mix Instance Group and
	// Network Endpoint Group backends.
	// When the load_balancing_scheme is INTERNAL, only instance groups
	// are supported.
	// Note that you must specify an Instance Group or Network Endpoint
	// Group resource using the fully-qualified URL, rather than a
	// partial URL.
	// +kubebuilder:validation:Optional
	Group *string `json:"group" tf:"group,omitempty"`

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// Cannot be set for INTERNAL backend services.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	// +kubebuilder:validation:Optional
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. Cannot be set
	// for INTERNAL backend services.
	// This is used to calculate the capacity of the group. Can be
	// used in either CONNECTION or UTILIZATION balancing modes. For
	// CONNECTION mode, either maxConnections or
	// maxConnectionsPerEndpoint must be set.
	// +kubebuilder:validation:Optional
	MaxConnectionsPerEndpoint *float64 `json:"maxConnectionsPerEndpoint,omitempty" tf:"max_connections_per_endpoint,omitempty"`

	// The max number of simultaneous connections that a single
	// backend instance can handle. Cannot be set for INTERNAL backend
	// services.
	// This is used to calculate the capacity of the group.
	// Can be used in either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	// +kubebuilder:validation:Optional
	MaxConnectionsPerInstance *float64 `json:"maxConnectionsPerInstance,omitempty" tf:"max_connections_per_instance,omitempty"`

	// The max requests per second (RPS) of the group. Cannot be set
	// for INTERNAL backend services.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. Either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	// +kubebuilder:validation:Optional
	MaxRate *float64 `json:"maxRate,omitempty" tf:"max_rate,omitempty"`

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set. Cannot be set
	// for INTERNAL backend services.
	// +kubebuilder:validation:Optional
	MaxRatePerEndpoint *float64 `json:"maxRatePerEndpoint,omitempty" tf:"max_rate_per_endpoint,omitempty"`

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set. Cannot be set
	// for INTERNAL backend services.
	// +kubebuilder:validation:Optional
	MaxRatePerInstance *float64 `json:"maxRatePerInstance,omitempty" tf:"max_rate_per_instance,omitempty"`

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	// Cannot be set for INTERNAL backend services.
	// +kubebuilder:validation:Optional
	MaxUtilization *float64 `json:"maxUtilization,omitempty" tf:"max_utilization,omitempty"`
}

type BaseEjectionTimeInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type BaseEjectionTimeObservation struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type BaseEjectionTimeParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds" tf:"seconds,omitempty"`
}

type CacheKeyPolicyInitParameters struct {

	// If true requests to different hosts will be cached separately.
	IncludeHost *bool `json:"includeHost,omitempty" tf:"include_host,omitempty"`

	// Names of cookies to include in cache keys.
	IncludeNamedCookies []*string `json:"includeNamedCookies,omitempty" tf:"include_named_cookies,omitempty"`

	// If true, http and https requests will be cached separately.
	IncludeProtocol *bool `json:"includeProtocol,omitempty" tf:"include_protocol,omitempty"`

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	IncludeQueryString *bool `json:"includeQueryString,omitempty" tf:"include_query_string,omitempty"`

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +listType=set
	QueryStringBlacklist []*string `json:"queryStringBlacklist,omitempty" tf:"query_string_blacklist,omitempty"`

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +listType=set
	QueryStringWhitelist []*string `json:"queryStringWhitelist,omitempty" tf:"query_string_whitelist,omitempty"`
}

type CacheKeyPolicyObservation struct {

	// If true requests to different hosts will be cached separately.
	IncludeHost *bool `json:"includeHost,omitempty" tf:"include_host,omitempty"`

	// Names of cookies to include in cache keys.
	IncludeNamedCookies []*string `json:"includeNamedCookies,omitempty" tf:"include_named_cookies,omitempty"`

	// If true, http and https requests will be cached separately.
	IncludeProtocol *bool `json:"includeProtocol,omitempty" tf:"include_protocol,omitempty"`

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	IncludeQueryString *bool `json:"includeQueryString,omitempty" tf:"include_query_string,omitempty"`

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +listType=set
	QueryStringBlacklist []*string `json:"queryStringBlacklist,omitempty" tf:"query_string_blacklist,omitempty"`

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +listType=set
	QueryStringWhitelist []*string `json:"queryStringWhitelist,omitempty" tf:"query_string_whitelist,omitempty"`
}

type CacheKeyPolicyParameters struct {

	// If true requests to different hosts will be cached separately.
	// +kubebuilder:validation:Optional
	IncludeHost *bool `json:"includeHost,omitempty" tf:"include_host,omitempty"`

	// Names of cookies to include in cache keys.
	// +kubebuilder:validation:Optional
	IncludeNamedCookies []*string `json:"includeNamedCookies,omitempty" tf:"include_named_cookies,omitempty"`

	// If true, http and https requests will be cached separately.
	// +kubebuilder:validation:Optional
	IncludeProtocol *bool `json:"includeProtocol,omitempty" tf:"include_protocol,omitempty"`

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	// +kubebuilder:validation:Optional
	IncludeQueryString *bool `json:"includeQueryString,omitempty" tf:"include_query_string,omitempty"`

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +kubebuilder:validation:Optional
	// +listType=set
	QueryStringBlacklist []*string `json:"queryStringBlacklist,omitempty" tf:"query_string_blacklist,omitempty"`

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +kubebuilder:validation:Optional
	// +listType=set
	QueryStringWhitelist []*string `json:"queryStringWhitelist,omitempty" tf:"query_string_whitelist,omitempty"`
}

type CdnPolicyInitParameters struct {

	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	CacheKeyPolicy *CacheKeyPolicyInitParameters `json:"cacheKeyPolicy,omitempty" tf:"cache_key_policy,omitempty"`

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	CacheMode *string `json:"cacheMode,omitempty" tf:"cache_mode,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	ClientTTL *float64 `json:"clientTtl,omitempty" tf:"client_ttl,omitempty"`

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	DefaultTTL *float64 `json:"defaultTtl,omitempty" tf:"default_ttl,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	MaxTTL *float64 `json:"maxTtl,omitempty" tf:"max_ttl,omitempty"`

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	NegativeCaching *bool `json:"negativeCaching,omitempty" tf:"negative_caching,omitempty"`

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	NegativeCachingPolicy []NegativeCachingPolicyInitParameters `json:"negativeCachingPolicy,omitempty" tf:"negative_caching_policy,omitempty"`

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	ServeWhileStale *float64 `json:"serveWhileStale,omitempty" tf:"serve_while_stale,omitempty"`

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	SignedURLCacheMaxAgeSec *float64 `json:"signedUrlCacheMaxAgeSec,omitempty" tf:"signed_url_cache_max_age_sec,omitempty"`
}

type CdnPolicyObservation struct {

	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	CacheKeyPolicy *CacheKeyPolicyObservation `json:"cacheKeyPolicy,omitempty" tf:"cache_key_policy,omitempty"`

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	CacheMode *string `json:"cacheMode,omitempty" tf:"cache_mode,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	ClientTTL *float64 `json:"clientTtl,omitempty" tf:"client_ttl,omitempty"`

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	DefaultTTL *float64 `json:"defaultTtl,omitempty" tf:"default_ttl,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	MaxTTL *float64 `json:"maxTtl,omitempty" tf:"max_ttl,omitempty"`

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	NegativeCaching *bool `json:"negativeCaching,omitempty" tf:"negative_caching,omitempty"`

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	NegativeCachingPolicy []NegativeCachingPolicyObservation `json:"negativeCachingPolicy,omitempty" tf:"negative_caching_policy,omitempty"`

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	ServeWhileStale *float64 `json:"serveWhileStale,omitempty" tf:"serve_while_stale,omitempty"`

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	SignedURLCacheMaxAgeSec *float64 `json:"signedUrlCacheMaxAgeSec,omitempty" tf:"signed_url_cache_max_age_sec,omitempty"`
}

type CdnPolicyParameters struct {

	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CacheKeyPolicy *CacheKeyPolicyParameters `json:"cacheKeyPolicy,omitempty" tf:"cache_key_policy,omitempty"`

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	// +kubebuilder:validation:Optional
	CacheMode *string `json:"cacheMode,omitempty" tf:"cache_mode,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	// +kubebuilder:validation:Optional
	ClientTTL *float64 `json:"clientTtl,omitempty" tf:"client_ttl,omitempty"`

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	// +kubebuilder:validation:Optional
	DefaultTTL *float64 `json:"defaultTtl,omitempty" tf:"default_ttl,omitempty"`

	// Specifies the maximum allowed TTL for cached content served by this origin.
	// +kubebuilder:validation:Optional
	MaxTTL *float64 `json:"maxTtl,omitempty" tf:"max_ttl,omitempty"`

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	// +kubebuilder:validation:Optional
	NegativeCaching *bool `json:"negativeCaching,omitempty" tf:"negative_caching,omitempty"`

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	NegativeCachingPolicy []NegativeCachingPolicyParameters `json:"negativeCachingPolicy,omitempty" tf:"negative_caching_policy,omitempty"`

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	// +kubebuilder:validation:Optional
	ServeWhileStale *float64 `json:"serveWhileStale,omitempty" tf:"serve_while_stale,omitempty"`

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	// +kubebuilder:validation:Optional
	SignedURLCacheMaxAgeSec *float64 `json:"signedUrlCacheMaxAgeSec,omitempty" tf:"signed_url_cache_max_age_sec,omitempty"`
}

type CircuitBreakersInitParameters struct {

	// The timeout for new network connections to hosts.
	// Structure is documented below.
	ConnectTimeout *ConnectTimeoutInitParameters `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	MaxPendingRequests *float64 `json:"maxPendingRequests,omitempty" tf:"max_pending_requests,omitempty"`

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	MaxRequests *float64 `json:"maxRequests,omitempty" tf:"max_requests,omitempty"`

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	MaxRequestsPerConnection *float64 `json:"maxRequestsPerConnection,omitempty" tf:"max_requests_per_connection,omitempty"`

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	MaxRetries *float64 `json:"maxRetries,omitempty" tf:"max_retries,omitempty"`
}

type CircuitBreakersObservation struct {

	// The timeout for new network connections to hosts.
	// Structure is documented below.
	ConnectTimeout *ConnectTimeoutObservation `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	MaxPendingRequests *float64 `json:"maxPendingRequests,omitempty" tf:"max_pending_requests,omitempty"`

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	MaxRequests *float64 `json:"maxRequests,omitempty" tf:"max_requests,omitempty"`

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	MaxRequestsPerConnection *float64 `json:"maxRequestsPerConnection,omitempty" tf:"max_requests_per_connection,omitempty"`

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	MaxRetries *float64 `json:"maxRetries,omitempty" tf:"max_retries,omitempty"`
}

type CircuitBreakersParameters struct {

	// The timeout for new network connections to hosts.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ConnectTimeout *ConnectTimeoutParameters `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	MaxPendingRequests *float64 `json:"maxPendingRequests,omitempty" tf:"max_pending_requests,omitempty"`

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	MaxRequests *float64 `json:"maxRequests,omitempty" tf:"max_requests,omitempty"`

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	// +kubebuilder:validation:Optional
	MaxRequestsPerConnection *float64 `json:"maxRequestsPerConnection,omitempty" tf:"max_requests_per_connection,omitempty"`

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	// +kubebuilder:validation:Optional
	MaxRetries *float64 `json:"maxRetries,omitempty" tf:"max_retries,omitempty"`
}

type ConnectTimeoutInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type ConnectTimeoutObservation struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type ConnectTimeoutParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds" tf:"seconds,omitempty"`
}

type ConnectionTrackingPolicyInitParameters struct {

	// Specifies connection persistence when backends are unhealthy.
	// If set to DEFAULT_FOR_PROTOCOL, the existing connections persist on
	// unhealthy backends only for connection-oriented protocols (TCP and SCTP)
	// and only if the Tracking Mode is PER_CONNECTION (default tracking mode)
	// or the Session Affinity is configured for 5-tuple. They do not persist
	// for UDP.
	// If set to NEVER_PERSIST, after a backend becomes unhealthy, the existing
	// connections on the unhealthy backend are never persisted on the unhealthy
	// backend. They are always diverted to newly selected healthy backends
	// (unless all backends are unhealthy).
	// If set to ALWAYS_PERSIST, existing connections always persist on
	// unhealthy backends regardless of protocol and session affinity. It is
	// generally not recommended to use this mode overriding the default.
	// Default value is DEFAULT_FOR_PROTOCOL.
	// Possible values are: DEFAULT_FOR_PROTOCOL, NEVER_PERSIST, ALWAYS_PERSIST.
	ConnectionPersistenceOnUnhealthyBackends *string `json:"connectionPersistenceOnUnhealthyBackends,omitempty" tf:"connection_persistence_on_unhealthy_backends,omitempty"`

	// Enable Strong Session Affinity for Network Load Balancing. This option is not available publicly.
	EnableStrongAffinity *bool `json:"enableStrongAffinity,omitempty" tf:"enable_strong_affinity,omitempty"`

	// Specifies how long to keep a Connection Tracking entry while there is
	// no matching traffic (in seconds).
	// For L4 ILB the minimum(default) is 10 minutes and maximum is 16 hours.
	// For NLB the minimum(default) is 60 seconds and the maximum is 16 hours.
	IdleTimeoutSec *float64 `json:"idleTimeoutSec,omitempty" tf:"idle_timeout_sec,omitempty"`

	// Specifies the key used for connection tracking. There are two options:
	// PER_CONNECTION: The Connection Tracking is performed as per the
	// Connection Key (default Hash Method) for the specific protocol.
	// PER_SESSION: The Connection Tracking is performed as per the
	// configured Session Affinity. It matches the configured Session Affinity.
	// Default value is PER_CONNECTION.
	// Possible values are: PER_CONNECTION, PER_SESSION.
	TrackingMode *string `json:"trackingMode,omitempty" tf:"tracking_mode,omitempty"`
}

type ConnectionTrackingPolicyObservation struct {

	// Specifies connection persistence when backends are unhealthy.
	// If set to DEFAULT_FOR_PROTOCOL, the existing connections persist on
	// unhealthy backends only for connection-oriented protocols (TCP and SCTP)
	// and only if the Tracking Mode is PER_CONNECTION (default tracking mode)
	// or the Session Affinity is configured for 5-tuple. They do not persist
	// for UDP.
	// If set to NEVER_PERSIST, after a backend becomes unhealthy, the existing
	// connections on the unhealthy backend are never persisted on the unhealthy
	// backend. They are always diverted to newly selected healthy backends
	// (unless all backends are unhealthy).
	// If set to ALWAYS_PERSIST, existing connections always persist on
	// unhealthy backends regardless of protocol and session affinity. It is
	// generally not recommended to use this mode overriding the default.
	// Default value is DEFAULT_FOR_PROTOCOL.
	// Possible values are: DEFAULT_FOR_PROTOCOL, NEVER_PERSIST, ALWAYS_PERSIST.
	ConnectionPersistenceOnUnhealthyBackends *string `json:"connectionPersistenceOnUnhealthyBackends,omitempty" tf:"connection_persistence_on_unhealthy_backends,omitempty"`

	// Enable Strong Session Affinity for Network Load Balancing. This option is not available publicly.
	EnableStrongAffinity *bool `json:"enableStrongAffinity,omitempty" tf:"enable_strong_affinity,omitempty"`

	// Specifies how long to keep a Connection Tracking entry while there is
	// no matching traffic (in seconds).
	// For L4 ILB the minimum(default) is 10 minutes and maximum is 16 hours.
	// For NLB the minimum(default) is 60 seconds and the maximum is 16 hours.
	IdleTimeoutSec *float64 `json:"idleTimeoutSec,omitempty" tf:"idle_timeout_sec,omitempty"`

	// Specifies the key used for connection tracking. There are two options:
	// PER_CONNECTION: The Connection Tracking is performed as per the
	// Connection Key (default Hash Method) for the specific protocol.
	// PER_SESSION: The Connection Tracking is performed as per the
	// configured Session Affinity. It matches the configured Session Affinity.
	// Default value is PER_CONNECTION.
	// Possible values are: PER_CONNECTION, PER_SESSION.
	TrackingMode *string `json:"trackingMode,omitempty" tf:"tracking_mode,omitempty"`
}

type ConnectionTrackingPolicyParameters struct {

	// Specifies connection persistence when backends are unhealthy.
	// If set to DEFAULT_FOR_PROTOCOL, the existing connections persist on
	// unhealthy backends only for connection-oriented protocols (TCP and SCTP)
	// and only if the Tracking Mode is PER_CONNECTION (default tracking mode)
	// or the Session Affinity is configured for 5-tuple. They do not persist
	// for UDP.
	// If set to NEVER_PERSIST, after a backend becomes unhealthy, the existing
	// connections on the unhealthy backend are never persisted on the unhealthy
	// backend. They are always diverted to newly selected healthy backends
	// (unless all backends are unhealthy).
	// If set to ALWAYS_PERSIST, existing connections always persist on
	// unhealthy backends regardless of protocol and session affinity. It is
	// generally not recommended to use this mode overriding the default.
	// Default value is DEFAULT_FOR_PROTOCOL.
	// Possible values are: DEFAULT_FOR_PROTOCOL, NEVER_PERSIST, ALWAYS_PERSIST.
	// +kubebuilder:validation:Optional
	ConnectionPersistenceOnUnhealthyBackends *string `json:"connectionPersistenceOnUnhealthyBackends,omitempty" tf:"connection_persistence_on_unhealthy_backends,omitempty"`

	// Enable Strong Session Affinity for Network Load Balancing. This option is not available publicly.
	// +kubebuilder:validation:Optional
	EnableStrongAffinity *bool `json:"enableStrongAffinity,omitempty" tf:"enable_strong_affinity,omitempty"`

	// Specifies how long to keep a Connection Tracking entry while there is
	// no matching traffic (in seconds).
	// For L4 ILB the minimum(default) is 10 minutes and maximum is 16 hours.
	// For NLB the minimum(default) is 60 seconds and the maximum is 16 hours.
	// +kubebuilder:validation:Optional
	IdleTimeoutSec *float64 `json:"idleTimeoutSec,omitempty" tf:"idle_timeout_sec,omitempty"`

	// Specifies the key used for connection tracking. There are two options:
	// PER_CONNECTION: The Connection Tracking is performed as per the
	// Connection Key (default Hash Method) for the specific protocol.
	// PER_SESSION: The Connection Tracking is performed as per the
	// configured Session Affinity. It matches the configured Session Affinity.
	// Default value is PER_CONNECTION.
	// Possible values are: PER_CONNECTION, PER_SESSION.
	// +kubebuilder:validation:Optional
	TrackingMode *string `json:"trackingMode,omitempty" tf:"tracking_mode,omitempty"`
}

type ConsistentHashInitParameters struct {

	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	HTTPCookie *HTTPCookieInitParameters `json:"httpCookie,omitempty" tf:"http_cookie,omitempty"`

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	HTTPHeaderName *string `json:"httpHeaderName,omitempty" tf:"http_header_name,omitempty"`

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	MinimumRingSize *float64 `json:"minimumRingSize,omitempty" tf:"minimum_ring_size,omitempty"`
}

type ConsistentHashObservation struct {

	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	HTTPCookie *HTTPCookieObservation `json:"httpCookie,omitempty" tf:"http_cookie,omitempty"`

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	HTTPHeaderName *string `json:"httpHeaderName,omitempty" tf:"http_header_name,omitempty"`

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	MinimumRingSize *float64 `json:"minimumRingSize,omitempty" tf:"minimum_ring_size,omitempty"`
}

type ConsistentHashParameters struct {

	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HTTPCookie *HTTPCookieParameters `json:"httpCookie,omitempty" tf:"http_cookie,omitempty"`

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	// +kubebuilder:validation:Optional
	HTTPHeaderName *string `json:"httpHeaderName,omitempty" tf:"http_header_name,omitempty"`

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	MinimumRingSize *float64 `json:"minimumRingSize,omitempty" tf:"minimum_ring_size,omitempty"`
}

type CustomMetricsInitParameters struct {

	// If true, the metric data is collected and reported to Cloud
	// Monitoring, but is not used for load balancing.
	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	// Optional parameter to define a target utilization for the Custom Metrics
	// balancing mode. The valid range is [0.0, 1.0].
	MaxUtilization *float64 `json:"maxUtilization,omitempty" tf:"max_utilization,omitempty"`

	// Name of the cookie.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type CustomMetricsObservation struct {

	// If true, the metric data is collected and reported to Cloud
	// Monitoring, but is not used for load balancing.
	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	// Optional parameter to define a target utilization for the Custom Metrics
	// balancing mode. The valid range is [0.0, 1.0].
	MaxUtilization *float64 `json:"maxUtilization,omitempty" tf:"max_utilization,omitempty"`

	// Name of the cookie.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type CustomMetricsParameters struct {

	// If true, the metric data is collected and reported to Cloud
	// Monitoring, but is not used for load balancing.
	// +kubebuilder:validation:Optional
	DryRun *bool `json:"dryRun" tf:"dry_run,omitempty"`

	// Optional parameter to define a target utilization for the Custom Metrics
	// balancing mode. The valid range is [0.0, 1.0].
	// +kubebuilder:validation:Optional
	MaxUtilization *float64 `json:"maxUtilization,omitempty" tf:"max_utilization,omitempty"`

	// Name of the cookie.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type DynamicForwardingInitParameters struct {

	// IP:PORT based dynamic forwarding configuration.
	// Structure is documented below.
	IPPortSelection *IPPortSelectionInitParameters `json:"ipPortSelection,omitempty" tf:"ip_port_selection,omitempty"`
}

type DynamicForwardingObservation struct {

	// IP:PORT based dynamic forwarding configuration.
	// Structure is documented below.
	IPPortSelection *IPPortSelectionObservation `json:"ipPortSelection,omitempty" tf:"ip_port_selection,omitempty"`
}

type DynamicForwardingParameters struct {

	// IP:PORT based dynamic forwarding configuration.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	IPPortSelection *IPPortSelectionParameters `json:"ipPortSelection,omitempty" tf:"ip_port_selection,omitempty"`
}

type FailoverPolicyInitParameters struct {

	// On failover or failback, this field indicates whether connection drain
	// will be honored. Setting this to true has the following effect: connections
	// to the old active pool are not drained. Connections to the new active pool
	// use the timeout of 10 min (currently fixed). Setting to false has the
	// following effect: both old and new connections will have a drain timeout
	// of 10 min.
	// This can be set to true only if the protocol is TCP.
	// The default is false.
	DisableConnectionDrainOnFailover *bool `json:"disableConnectionDrainOnFailover,omitempty" tf:"disable_connection_drain_on_failover,omitempty"`

	// This option is used only when no healthy VMs are detected in the primary
	// and backup instance groups. When set to true, traffic is dropped. When
	// set to false, new connections are sent across all VMs in the primary group.
	// The default is false.
	DropTrafficIfUnhealthy *bool `json:"dropTrafficIfUnhealthy,omitempty" tf:"drop_traffic_if_unhealthy,omitempty"`

	// The value of the field must be in [0, 1]. If the ratio of the healthy
	// VMs in the primary backend is at or below this number, traffic arriving
	// at the load-balanced IP will be directed to the failover backend.
	// In case where 'failoverRatio' is not set or all the VMs in the backup
	// backend are unhealthy, the traffic will be directed back to the primary
	// backend in the "force" mode, where traffic will be spread to the healthy
	// VMs with the best effort, or to all VMs when no VM is healthy.
	// This field is only used with l4 load balancing.
	FailoverRatio *float64 `json:"failoverRatio,omitempty" tf:"failover_ratio,omitempty"`
}

type FailoverPolicyObservation struct {

	// On failover or failback, this field indicates whether connection drain
	// will be honored. Setting this to true has the following effect: connections
	// to the old active pool are not drained. Connections to the new active pool
	// use the timeout of 10 min (currently fixed). Setting to false has the
	// following effect: both old and new connections will have a drain timeout
	// of 10 min.
	// This can be set to true only if the protocol is TCP.
	// The default is false.
	DisableConnectionDrainOnFailover *bool `json:"disableConnectionDrainOnFailover,omitempty" tf:"disable_connection_drain_on_failover,omitempty"`

	// This option is used only when no healthy VMs are detected in the primary
	// and backup instance groups. When set to true, traffic is dropped. When
	// set to false, new connections are sent across all VMs in the primary group.
	// The default is false.
	DropTrafficIfUnhealthy *bool `json:"dropTrafficIfUnhealthy,omitempty" tf:"drop_traffic_if_unhealthy,omitempty"`

	// The value of the field must be in [0, 1]. If the ratio of the healthy
	// VMs in the primary backend is at or below this number, traffic arriving
	// at the load-balanced IP will be directed to the failover backend.
	// In case where 'failoverRatio' is not set or all the VMs in the backup
	// backend are unhealthy, the traffic will be directed back to the primary
	// backend in the "force" mode, where traffic will be spread to the healthy
	// VMs with the best effort, or to all VMs when no VM is healthy.
	// This field is only used with l4 load balancing.
	FailoverRatio *float64 `json:"failoverRatio,omitempty" tf:"failover_ratio,omitempty"`
}

type FailoverPolicyParameters struct {

	// On failover or failback, this field indicates whether connection drain
	// will be honored. Setting this to true has the following effect: connections
	// to the old active pool are not drained. Connections to the new active pool
	// use the timeout of 10 min (currently fixed). Setting to false has the
	// following effect: both old and new connections will have a drain timeout
	// of 10 min.
	// This can be set to true only if the protocol is TCP.
	// The default is false.
	// +kubebuilder:validation:Optional
	DisableConnectionDrainOnFailover *bool `json:"disableConnectionDrainOnFailover,omitempty" tf:"disable_connection_drain_on_failover,omitempty"`

	// This option is used only when no healthy VMs are detected in the primary
	// and backup instance groups. When set to true, traffic is dropped. When
	// set to false, new connections are sent across all VMs in the primary group.
	// The default is false.
	// +kubebuilder:validation:Optional
	DropTrafficIfUnhealthy *bool `json:"dropTrafficIfUnhealthy,omitempty" tf:"drop_traffic_if_unhealthy,omitempty"`

	// The value of the field must be in [0, 1]. If the ratio of the healthy
	// VMs in the primary backend is at or below this number, traffic arriving
	// at the load-balanced IP will be directed to the failover backend.
	// In case where 'failoverRatio' is not set or all the VMs in the backup
	// backend are unhealthy, the traffic will be directed back to the primary
	// backend in the "force" mode, where traffic will be spread to the healthy
	// VMs with the best effort, or to all VMs when no VM is healthy.
	// This field is only used with l4 load balancing.
	// +kubebuilder:validation:Optional
	FailoverRatio *float64 `json:"failoverRatio,omitempty" tf:"failover_ratio,omitempty"`
}

type HTTPCookieInitParameters struct {

	// Name of the cookie.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to set for the cookie.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Lifetime of the cookie.
	// Structure is documented below.
	TTL *TTLInitParameters `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type HTTPCookieObservation struct {

	// Name of the cookie.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to set for the cookie.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Lifetime of the cookie.
	// Structure is documented below.
	TTL *TTLObservation `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type HTTPCookieParameters struct {

	// Name of the cookie.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to set for the cookie.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Lifetime of the cookie.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	TTL *TTLParameters `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type IPPortSelectionInitParameters struct {

	// A boolean flag enabling IP:PORT based dynamic forwarding.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type IPPortSelectionObservation struct {

	// A boolean flag enabling IP:PORT based dynamic forwarding.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type IPPortSelectionParameters struct {

	// A boolean flag enabling IP:PORT based dynamic forwarding.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type IapInitParameters struct {

	// Whether the serving infrastructure will authenticate and authorize all incoming requests.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// OAuth2 Client ID for IAP
	Oauth2ClientID *string `json:"oauth2ClientId,omitempty" tf:"oauth2_client_id,omitempty"`

	// OAuth2 Client Secret for IAP
	// Note: This property is sensitive and will not be displayed in the plan.
	Oauth2ClientSecretSecretRef *v1.SecretKeySelector `json:"oauth2ClientSecretSecretRef,omitempty" tf:"-"`
}

type IapObservation struct {

	// Whether the serving infrastructure will authenticate and authorize all incoming requests.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// OAuth2 Client ID for IAP
	Oauth2ClientID *string `json:"oauth2ClientId,omitempty" tf:"oauth2_client_id,omitempty"`
}

type IapParameters struct {

	// Whether the serving infrastructure will authenticate and authorize all incoming requests.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// OAuth2 Client ID for IAP
	// +kubebuilder:validation:Optional
	Oauth2ClientID *string `json:"oauth2ClientId,omitempty" tf:"oauth2_client_id,omitempty"`

	// OAuth2 Client Secret for IAP
	// Note: This property is sensitive and will not be displayed in the plan.
	// +kubebuilder:validation:Optional
	Oauth2ClientSecretSecretRef *v1.SecretKeySelector `json:"oauth2ClientSecretSecretRef,omitempty" tf:"-"`
}

type IntervalInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type IntervalObservation struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type IntervalParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds" tf:"seconds,omitempty"`
}

type NegativeCachingPolicyInitParameters struct {

	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	Code *float64 `json:"code,omitempty" tf:"code,omitempty"`

	// Lifetime of the cookie.
	// Structure is documented below.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NegativeCachingPolicyObservation struct {

	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	Code *float64 `json:"code,omitempty" tf:"code,omitempty"`

	// Lifetime of the cookie.
	// Structure is documented below.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NegativeCachingPolicyParameters struct {

	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	// +kubebuilder:validation:Optional
	Code *float64 `json:"code,omitempty" tf:"code,omitempty"`

	// Lifetime of the cookie.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type OutlierDetectionInitParameters struct {

	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	BaseEjectionTime *BaseEjectionTimeInitParameters `json:"baseEjectionTime,omitempty" tf:"base_ejection_time,omitempty"`

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	ConsecutiveErrors *float64 `json:"consecutiveErrors,omitempty" tf:"consecutive_errors,omitempty"`

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	ConsecutiveGatewayFailure *float64 `json:"consecutiveGatewayFailure,omitempty" tf:"consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	EnforcingConsecutiveErrors *float64 `json:"enforcingConsecutiveErrors,omitempty" tf:"enforcing_consecutive_errors,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	EnforcingConsecutiveGatewayFailure *float64 `json:"enforcingConsecutiveGatewayFailure,omitempty" tf:"enforcing_consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	EnforcingSuccessRate *float64 `json:"enforcingSuccessRate,omitempty" tf:"enforcing_success_rate,omitempty"`

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	Interval *IntervalInitParameters `json:"interval,omitempty" tf:"interval,omitempty"`

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	MaxEjectionPercent *float64 `json:"maxEjectionPercent,omitempty" tf:"max_ejection_percent,omitempty"`

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	SuccessRateMinimumHosts *float64 `json:"successRateMinimumHosts,omitempty" tf:"success_rate_minimum_hosts,omitempty"`

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	SuccessRateRequestVolume *float64 `json:"successRateRequestVolume,omitempty" tf:"success_rate_request_volume,omitempty"`

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	SuccessRateStdevFactor *float64 `json:"successRateStdevFactor,omitempty" tf:"success_rate_stdev_factor,omitempty"`
}

type OutlierDetectionObservation struct {

	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	BaseEjectionTime *BaseEjectionTimeObservation `json:"baseEjectionTime,omitempty" tf:"base_ejection_time,omitempty"`

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	ConsecutiveErrors *float64 `json:"consecutiveErrors,omitempty" tf:"consecutive_errors,omitempty"`

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	ConsecutiveGatewayFailure *float64 `json:"consecutiveGatewayFailure,omitempty" tf:"consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	EnforcingConsecutiveErrors *float64 `json:"enforcingConsecutiveErrors,omitempty" tf:"enforcing_consecutive_errors,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	EnforcingConsecutiveGatewayFailure *float64 `json:"enforcingConsecutiveGatewayFailure,omitempty" tf:"enforcing_consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	EnforcingSuccessRate *float64 `json:"enforcingSuccessRate,omitempty" tf:"enforcing_success_rate,omitempty"`

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	Interval *IntervalObservation `json:"interval,omitempty" tf:"interval,omitempty"`

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	MaxEjectionPercent *float64 `json:"maxEjectionPercent,omitempty" tf:"max_ejection_percent,omitempty"`

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	SuccessRateMinimumHosts *float64 `json:"successRateMinimumHosts,omitempty" tf:"success_rate_minimum_hosts,omitempty"`

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	SuccessRateRequestVolume *float64 `json:"successRateRequestVolume,omitempty" tf:"success_rate_request_volume,omitempty"`

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	SuccessRateStdevFactor *float64 `json:"successRateStdevFactor,omitempty" tf:"success_rate_stdev_factor,omitempty"`
}

type OutlierDetectionParameters struct {

	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	BaseEjectionTime *BaseEjectionTimeParameters `json:"baseEjectionTime,omitempty" tf:"base_ejection_time,omitempty"`

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	// +kubebuilder:validation:Optional
	ConsecutiveErrors *float64 `json:"consecutiveErrors,omitempty" tf:"consecutive_errors,omitempty"`

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	// +kubebuilder:validation:Optional
	ConsecutiveGatewayFailure *float64 `json:"consecutiveGatewayFailure,omitempty" tf:"consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	// +kubebuilder:validation:Optional
	EnforcingConsecutiveErrors *float64 `json:"enforcingConsecutiveErrors,omitempty" tf:"enforcing_consecutive_errors,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	// +kubebuilder:validation:Optional
	EnforcingConsecutiveGatewayFailure *float64 `json:"enforcingConsecutiveGatewayFailure,omitempty" tf:"enforcing_consecutive_gateway_failure,omitempty"`

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	// +kubebuilder:validation:Optional
	EnforcingSuccessRate *float64 `json:"enforcingSuccessRate,omitempty" tf:"enforcing_success_rate,omitempty"`

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Interval *IntervalParameters `json:"interval,omitempty" tf:"interval,omitempty"`

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	// +kubebuilder:validation:Optional
	MaxEjectionPercent *float64 `json:"maxEjectionPercent,omitempty" tf:"max_ejection_percent,omitempty"`

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	// +kubebuilder:validation:Optional
	SuccessRateMinimumHosts *float64 `json:"successRateMinimumHosts,omitempty" tf:"success_rate_minimum_hosts,omitempty"`

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	// +kubebuilder:validation:Optional
	SuccessRateRequestVolume *float64 `json:"successRateRequestVolume,omitempty" tf:"success_rate_request_volume,omitempty"`

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	// +kubebuilder:validation:Optional
	SuccessRateStdevFactor *float64 `json:"successRateStdevFactor,omitempty" tf:"success_rate_stdev_factor,omitempty"`
}

type RegionBackendServiceCustomMetricsInitParameters struct {

	// If true, the metric data is collected and reported to Cloud
	// Monitoring, but is not used for load balancing.
	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	// Name of a custom utilization signal. The name must be 1-64 characters
	// long and match the regular expression a-z? which
	// means the first character must be a lowercase letter, and all following
	// characters must be a dash, period, underscore, lowercase letter, or
	// digit, except the last character, which cannot be a dash, period, or
	// underscore. For usage guidelines, see Custom Metrics balancing mode. This
	// field can only be used for a global or regional backend service with the
	// loadBalancingScheme set to EXTERNAL_MANAGED,
	// INTERNAL_MANAGED INTERNAL_SELF_MANAGED.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type RegionBackendServiceCustomMetricsObservation struct {

	// If true, the metric data is collected and reported to Cloud
	// Monitoring, but is not used for load balancing.
	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	// Name of a custom utilization signal. The name must be 1-64 characters
	// long and match the regular expression a-z? which
	// means the first character must be a lowercase letter, and all following
	// characters must be a dash, period, underscore, lowercase letter, or
	// digit, except the last character, which cannot be a dash, period, or
	// underscore. For usage guidelines, see Custom Metrics balancing mode. This
	// field can only be used for a global or regional backend service with the
	// loadBalancingScheme set to EXTERNAL_MANAGED,
	// INTERNAL_MANAGED INTERNAL_SELF_MANAGED.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type RegionBackendServiceCustomMetricsParameters struct {

	// If true, the metric data is collected and reported to Cloud
	// Monitoring, but is not used for load balancing.
	// +kubebuilder:validation:Optional
	DryRun *bool `json:"dryRun" tf:"dry_run,omitempty"`

	// Name of a custom utilization signal. The name must be 1-64 characters
	// long and match the regular expression a-z? which
	// means the first character must be a lowercase letter, and all following
	// characters must be a dash, period, underscore, lowercase letter, or
	// digit, except the last character, which cannot be a dash, period, or
	// underscore. For usage guidelines, see Custom Metrics balancing mode. This
	// field can only be used for a global or regional backend service with the
	// loadBalancingScheme set to EXTERNAL_MANAGED,
	// INTERNAL_MANAGED INTERNAL_SELF_MANAGED.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type RegionBackendServiceInitParameters struct {

	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	AffinityCookieTTLSec *float64 `json:"affinityCookieTtlSec,omitempty" tf:"affinity_cookie_ttl_sec,omitempty"`

	// The set of backends that serve this RegionBackendService.
	// Structure is documented below.
	Backend []BackendInitParameters `json:"backend,omitempty" tf:"backend,omitempty"`

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	CdnPolicy *CdnPolicyInitParameters `json:"cdnPolicy,omitempty" tf:"cdn_policy,omitempty"`

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_MANAGED
	// and the protocol is set to HTTP, HTTPS, HTTP2 or H2C.
	// Structure is documented below.
	CircuitBreakers *CircuitBreakersInitParameters `json:"circuitBreakers,omitempty" tf:"circuit_breakers,omitempty"`

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	ConnectionDrainingTimeoutSec *float64 `json:"connectionDrainingTimeoutSec,omitempty" tf:"connection_draining_timeout_sec,omitempty"`

	// Connection Tracking configuration for this BackendService.
	// This is available only for Layer 4 Internal Load Balancing and
	// Network Load Balancing.
	// Structure is documented below.
	ConnectionTrackingPolicy *ConnectionTrackingPolicyInitParameters `json:"connectionTrackingPolicy,omitempty" tf:"connection_tracking_policy,omitempty"`

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing.
	// This field only applies when all of the following are true -
	ConsistentHash *ConsistentHashInitParameters `json:"consistentHash,omitempty" tf:"consistent_hash,omitempty"`

	// List of custom metrics that are used for the WEIGHTED_ROUND_ROBIN locality_lb_policy.
	// Structure is documented below.
	CustomMetrics []RegionBackendServiceCustomMetricsInitParameters `json:"customMetrics,omitempty" tf:"custom_metrics,omitempty"`

	// An optional description of this resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Dynamic forwarding configuration. This field is used to configure the backend service with dynamic forwarding
	// feature which together with Service Extension allows customized and complex routing logic.
	// Structure is documented below.
	DynamicForwarding *DynamicForwardingInitParameters `json:"dynamicForwarding,omitempty" tf:"dynamic_forwarding,omitempty"`

	// If true, enable Cloud CDN for this RegionBackendService.
	EnableCdn *bool `json:"enableCdn,omitempty" tf:"enable_cdn,omitempty"`

	// Policy for failovers.
	// Structure is documented below.
	FailoverPolicy *FailoverPolicyInitParameters `json:"failoverPolicy,omitempty" tf:"failover_policy,omitempty"`

	// The set of URLs to HealthCheck resources for health checking
	// this RegionBackendService. Currently at most one health
	// check can be specified.
	// A health check must be specified unless the backend service uses an internet
	// or serverless NEG as a backend.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp-beta/apis/cluster/compute/v1beta1.HealthCheck
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("id",true)
	// +listType=set
	HealthChecks []*string `json:"healthChecks,omitempty" tf:"health_checks,omitempty"`

	// References to HealthCheck in compute to populate healthChecks.
	// +kubebuilder:validation:Optional
	HealthChecksRefs []v1.Reference `json:"healthChecksRefs,omitempty" tf:"-"`

	// Selector for a list of HealthCheck in compute to populate healthChecks.
	// +kubebuilder:validation:Optional
	HealthChecksSelector *v1.Selector `json:"healthChecksSelector,omitempty" tf:"-"`

	// Specifies preference of traffic to the backend (from the proxy and from the client for proxyless gRPC).
	// Possible values are: IPV4_ONLY, PREFER_IPV6, IPV6_ONLY.
	IPAddressSelectionPolicy *string `json:"ipAddressSelectionPolicy,omitempty" tf:"ip_address_selection_policy,omitempty"`

	// Settings for enabling Cloud Identity Aware Proxy.
	// If OAuth client is not set, Google-managed OAuth client is used.
	// Structure is documented below.
	Iap *IapInitParameters `json:"iap,omitempty" tf:"iap,omitempty"`

	// is set to INTERNAL_MANAGED
	LoadBalancingScheme *string `json:"loadBalancingScheme,omitempty" tf:"load_balancing_scheme,omitempty"`

	// is set to MAGLEV or RING_HASH
	// Structure is documented below.
	LocalityLBPolicy *string `json:"localityLbPolicy,omitempty" tf:"locality_lb_policy,omitempty"`

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	LogConfig *RegionBackendServiceLogConfigInitParameters `json:"logConfig,omitempty" tf:"log_config,omitempty"`

	// The URL of the network to which this backend service belongs.
	// This field can only be specified when the load balancing scheme is set to INTERNAL.
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// This field is applicable only when the load_balancing_scheme is set
	// to INTERNAL_MANAGED and the protocol is set to HTTP, HTTPS, HTTP2 or H2C.
	// Structure is documented below.
	OutlierDetection *OutlierDetectionInitParameters `json:"outlierDetection,omitempty" tf:"outlier_detection,omitempty"`

	// A named port on a backend instance group representing the port for
	// communication to the backend VMs in that group. Required when the
	// loadBalancingScheme is EXTERNAL, EXTERNAL_MANAGED, INTERNAL_MANAGED, or INTERNAL_SELF_MANAGED
	// and the backends are instance groups. The named port must be defined on each
	// backend instance group. This parameter has no meaning if the backends are NEGs. API sets a
	// default of "http" if not given.
	// Must be omitted when the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
	PortName *string `json:"portName,omitempty" tf:"port_name,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// is set to HTTP, HTTPS, HTTP2 or H2C
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The security policy associated with this backend service.
	SecurityPolicy *string `json:"securityPolicy,omitempty" tf:"security_policy,omitempty"`

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE, CLIENT_IP_NO_DESTINATION, STRONG_COOKIE_AFFINITY.
	SessionAffinity *string `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// Describes the HTTP cookie used for stateful session affinity. This field is applicable and required if the sessionAffinity is set to STRONG_COOKIE_AFFINITY.
	// Structure is documented below.
	StrongSessionAffinityCookie *StrongSessionAffinityCookieInitParameters `json:"strongSessionAffinityCookie,omitempty" tf:"strong_session_affinity_cookie,omitempty"`

	// Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing and Internal HTTP(S) load balancing.
	// Structure is documented below.
	Subsetting *SubsettingInitParameters `json:"subsetting,omitempty" tf:"subsetting,omitempty"`

	// The backend service timeout has a different meaning depending on the type of load balancer.
	// For more information see, Backend service settings.
	// The default is 30 seconds.
	// The full range of timeout values allowed goes from 1 through 2,147,483,647 seconds.
	TimeoutSec *float64 `json:"timeoutSec,omitempty" tf:"timeout_sec,omitempty"`
}

type RegionBackendServiceLogConfigInitParameters struct {

	// Whether to enable logging for the load balancer traffic served by this backend service.
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Specifies the fields to include in logging. This field can only be specified if logging is enabled for this backend service.
	OptionalFields []*string `json:"optionalFields,omitempty" tf:"optional_fields,omitempty"`

	// Specifies the optional logging mode for the load balancer traffic.
	// Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
	// Possible values are: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
	OptionalMode *string `json:"optionalMode,omitempty" tf:"optional_mode,omitempty"`

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	SampleRate *float64 `json:"sampleRate,omitempty" tf:"sample_rate,omitempty"`
}

type RegionBackendServiceLogConfigObservation struct {

	// Whether to enable logging for the load balancer traffic served by this backend service.
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Specifies the fields to include in logging. This field can only be specified if logging is enabled for this backend service.
	OptionalFields []*string `json:"optionalFields,omitempty" tf:"optional_fields,omitempty"`

	// Specifies the optional logging mode for the load balancer traffic.
	// Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
	// Possible values are: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
	OptionalMode *string `json:"optionalMode,omitempty" tf:"optional_mode,omitempty"`

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	SampleRate *float64 `json:"sampleRate,omitempty" tf:"sample_rate,omitempty"`
}

type RegionBackendServiceLogConfigParameters struct {

	// Whether to enable logging for the load balancer traffic served by this backend service.
	// +kubebuilder:validation:Optional
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Specifies the fields to include in logging. This field can only be specified if logging is enabled for this backend service.
	// +kubebuilder:validation:Optional
	OptionalFields []*string `json:"optionalFields,omitempty" tf:"optional_fields,omitempty"`

	// Specifies the optional logging mode for the load balancer traffic.
	// Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
	// Possible values are: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
	// +kubebuilder:validation:Optional
	OptionalMode *string `json:"optionalMode,omitempty" tf:"optional_mode,omitempty"`

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	// +kubebuilder:validation:Optional
	SampleRate *float64 `json:"sampleRate,omitempty" tf:"sample_rate,omitempty"`
}

type RegionBackendServiceObservation struct {

	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	AffinityCookieTTLSec *float64 `json:"affinityCookieTtlSec,omitempty" tf:"affinity_cookie_ttl_sec,omitempty"`

	// The set of backends that serve this RegionBackendService.
	// Structure is documented below.
	Backend []BackendObservation `json:"backend,omitempty" tf:"backend,omitempty"`

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	CdnPolicy *CdnPolicyObservation `json:"cdnPolicy,omitempty" tf:"cdn_policy,omitempty"`

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_MANAGED
	// and the protocol is set to HTTP, HTTPS, HTTP2 or H2C.
	// Structure is documented below.
	CircuitBreakers *CircuitBreakersObservation `json:"circuitBreakers,omitempty" tf:"circuit_breakers,omitempty"`

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	ConnectionDrainingTimeoutSec *float64 `json:"connectionDrainingTimeoutSec,omitempty" tf:"connection_draining_timeout_sec,omitempty"`

	// Connection Tracking configuration for this BackendService.
	// This is available only for Layer 4 Internal Load Balancing and
	// Network Load Balancing.
	// Structure is documented below.
	ConnectionTrackingPolicy *ConnectionTrackingPolicyObservation `json:"connectionTrackingPolicy,omitempty" tf:"connection_tracking_policy,omitempty"`

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing.
	// This field only applies when all of the following are true -
	ConsistentHash *ConsistentHashObservation `json:"consistentHash,omitempty" tf:"consistent_hash,omitempty"`

	// Creation timestamp in RFC3339 text format.
	CreationTimestamp *string `json:"creationTimestamp,omitempty" tf:"creation_timestamp,omitempty"`

	// List of custom metrics that are used for the WEIGHTED_ROUND_ROBIN locality_lb_policy.
	// Structure is documented below.
	CustomMetrics []RegionBackendServiceCustomMetricsObservation `json:"customMetrics,omitempty" tf:"custom_metrics,omitempty"`

	// An optional description of this resource.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Dynamic forwarding configuration. This field is used to configure the backend service with dynamic forwarding
	// feature which together with Service Extension allows customized and complex routing logic.
	// Structure is documented below.
	DynamicForwarding *DynamicForwardingObservation `json:"dynamicForwarding,omitempty" tf:"dynamic_forwarding,omitempty"`

	// If true, enable Cloud CDN for this RegionBackendService.
	EnableCdn *bool `json:"enableCdn,omitempty" tf:"enable_cdn,omitempty"`

	// Policy for failovers.
	// Structure is documented below.
	FailoverPolicy *FailoverPolicyObservation `json:"failoverPolicy,omitempty" tf:"failover_policy,omitempty"`

	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking.
	Fingerprint *string `json:"fingerprint,omitempty" tf:"fingerprint,omitempty"`

	// The unique identifier for the resource. This identifier is defined by the server.
	GeneratedID *float64 `json:"generatedId,omitempty" tf:"generated_id,omitempty"`

	// The set of URLs to HealthCheck resources for health checking
	// this RegionBackendService. Currently at most one health
	// check can be specified.
	// A health check must be specified unless the backend service uses an internet
	// or serverless NEG as a backend.
	// +listType=set
	HealthChecks []*string `json:"healthChecks,omitempty" tf:"health_checks,omitempty"`

	// an identifier for the resource with format projects/{{project}}/regions/{{region}}/backendServices/{{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Specifies preference of traffic to the backend (from the proxy and from the client for proxyless gRPC).
	// Possible values are: IPV4_ONLY, PREFER_IPV6, IPV6_ONLY.
	IPAddressSelectionPolicy *string `json:"ipAddressSelectionPolicy,omitempty" tf:"ip_address_selection_policy,omitempty"`

	// Settings for enabling Cloud Identity Aware Proxy.
	// If OAuth client is not set, Google-managed OAuth client is used.
	// Structure is documented below.
	Iap *IapObservation `json:"iap,omitempty" tf:"iap,omitempty"`

	// is set to INTERNAL_MANAGED
	LoadBalancingScheme *string `json:"loadBalancingScheme,omitempty" tf:"load_balancing_scheme,omitempty"`

	// is set to MAGLEV or RING_HASH
	// Structure is documented below.
	LocalityLBPolicy *string `json:"localityLbPolicy,omitempty" tf:"locality_lb_policy,omitempty"`

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	LogConfig *RegionBackendServiceLogConfigObservation `json:"logConfig,omitempty" tf:"log_config,omitempty"`

	// The URL of the network to which this backend service belongs.
	// This field can only be specified when the load balancing scheme is set to INTERNAL.
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// This field is applicable only when the load_balancing_scheme is set
	// to INTERNAL_MANAGED and the protocol is set to HTTP, HTTPS, HTTP2 or H2C.
	// Structure is documented below.
	OutlierDetection *OutlierDetectionObservation `json:"outlierDetection,omitempty" tf:"outlier_detection,omitempty"`

	// A named port on a backend instance group representing the port for
	// communication to the backend VMs in that group. Required when the
	// loadBalancingScheme is EXTERNAL, EXTERNAL_MANAGED, INTERNAL_MANAGED, or INTERNAL_SELF_MANAGED
	// and the backends are instance groups. The named port must be defined on each
	// backend instance group. This parameter has no meaning if the backends are NEGs. API sets a
	// default of "http" if not given.
	// Must be omitted when the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
	PortName *string `json:"portName,omitempty" tf:"port_name,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// is set to HTTP, HTTPS, HTTP2 or H2C
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The Region in which the created backend service should reside.
	// If it is not provided, the provider region is used.
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The security policy associated with this backend service.
	SecurityPolicy *string `json:"securityPolicy,omitempty" tf:"security_policy,omitempty"`

	// The URI of the created resource.
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE, CLIENT_IP_NO_DESTINATION, STRONG_COOKIE_AFFINITY.
	SessionAffinity *string `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// Describes the HTTP cookie used for stateful session affinity. This field is applicable and required if the sessionAffinity is set to STRONG_COOKIE_AFFINITY.
	// Structure is documented below.
	StrongSessionAffinityCookie *StrongSessionAffinityCookieObservation `json:"strongSessionAffinityCookie,omitempty" tf:"strong_session_affinity_cookie,omitempty"`

	// Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing and Internal HTTP(S) load balancing.
	// Structure is documented below.
	Subsetting *SubsettingObservation `json:"subsetting,omitempty" tf:"subsetting,omitempty"`

	// The backend service timeout has a different meaning depending on the type of load balancer.
	// For more information see, Backend service settings.
	// The default is 30 seconds.
	// The full range of timeout values allowed goes from 1 through 2,147,483,647 seconds.
	TimeoutSec *float64 `json:"timeoutSec,omitempty" tf:"timeout_sec,omitempty"`
}

type RegionBackendServiceParameters struct {

	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	// +kubebuilder:validation:Optional
	AffinityCookieTTLSec *float64 `json:"affinityCookieTtlSec,omitempty" tf:"affinity_cookie_ttl_sec,omitempty"`

	// The set of backends that serve this RegionBackendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Backend []BackendParameters `json:"backend,omitempty" tf:"backend,omitempty"`

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CdnPolicy *CdnPolicyParameters `json:"cdnPolicy,omitempty" tf:"cdn_policy,omitempty"`

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_MANAGED
	// and the protocol is set to HTTP, HTTPS, HTTP2 or H2C.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CircuitBreakers *CircuitBreakersParameters `json:"circuitBreakers,omitempty" tf:"circuit_breakers,omitempty"`

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	// +kubebuilder:validation:Optional
	ConnectionDrainingTimeoutSec *float64 `json:"connectionDrainingTimeoutSec,omitempty" tf:"connection_draining_timeout_sec,omitempty"`

	// Connection Tracking configuration for this BackendService.
	// This is available only for Layer 4 Internal Load Balancing and
	// Network Load Balancing.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ConnectionTrackingPolicy *ConnectionTrackingPolicyParameters `json:"connectionTrackingPolicy,omitempty" tf:"connection_tracking_policy,omitempty"`

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing.
	// This field only applies when all of the following are true -
	// +kubebuilder:validation:Optional
	ConsistentHash *ConsistentHashParameters `json:"consistentHash,omitempty" tf:"consistent_hash,omitempty"`

	// List of custom metrics that are used for the WEIGHTED_ROUND_ROBIN locality_lb_policy.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	CustomMetrics []RegionBackendServiceCustomMetricsParameters `json:"customMetrics,omitempty" tf:"custom_metrics,omitempty"`

	// An optional description of this resource.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Dynamic forwarding configuration. This field is used to configure the backend service with dynamic forwarding
	// feature which together with Service Extension allows customized and complex routing logic.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	DynamicForwarding *DynamicForwardingParameters `json:"dynamicForwarding,omitempty" tf:"dynamic_forwarding,omitempty"`

	// If true, enable Cloud CDN for this RegionBackendService.
	// +kubebuilder:validation:Optional
	EnableCdn *bool `json:"enableCdn,omitempty" tf:"enable_cdn,omitempty"`

	// Policy for failovers.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	FailoverPolicy *FailoverPolicyParameters `json:"failoverPolicy,omitempty" tf:"failover_policy,omitempty"`

	// The set of URLs to HealthCheck resources for health checking
	// this RegionBackendService. Currently at most one health
	// check can be specified.
	// A health check must be specified unless the backend service uses an internet
	// or serverless NEG as a backend.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp-beta/apis/cluster/compute/v1beta1.HealthCheck
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("id",true)
	// +kubebuilder:validation:Optional
	// +listType=set
	HealthChecks []*string `json:"healthChecks,omitempty" tf:"health_checks,omitempty"`

	// References to HealthCheck in compute to populate healthChecks.
	// +kubebuilder:validation:Optional
	HealthChecksRefs []v1.Reference `json:"healthChecksRefs,omitempty" tf:"-"`

	// Selector for a list of HealthCheck in compute to populate healthChecks.
	// +kubebuilder:validation:Optional
	HealthChecksSelector *v1.Selector `json:"healthChecksSelector,omitempty" tf:"-"`

	// Specifies preference of traffic to the backend (from the proxy and from the client for proxyless gRPC).
	// Possible values are: IPV4_ONLY, PREFER_IPV6, IPV6_ONLY.
	// +kubebuilder:validation:Optional
	IPAddressSelectionPolicy *string `json:"ipAddressSelectionPolicy,omitempty" tf:"ip_address_selection_policy,omitempty"`

	// Settings for enabling Cloud Identity Aware Proxy.
	// If OAuth client is not set, Google-managed OAuth client is used.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Iap *IapParameters `json:"iap,omitempty" tf:"iap,omitempty"`

	// is set to INTERNAL_MANAGED
	// +kubebuilder:validation:Optional
	LoadBalancingScheme *string `json:"loadBalancingScheme,omitempty" tf:"load_balancing_scheme,omitempty"`

	// is set to MAGLEV or RING_HASH
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	LocalityLBPolicy *string `json:"localityLbPolicy,omitempty" tf:"locality_lb_policy,omitempty"`

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	LogConfig *RegionBackendServiceLogConfigParameters `json:"logConfig,omitempty" tf:"log_config,omitempty"`

	// The URL of the network to which this backend service belongs.
	// This field can only be specified when the load balancing scheme is set to INTERNAL.
	// +kubebuilder:validation:Optional
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// This field is applicable only when the load_balancing_scheme is set
	// to INTERNAL_MANAGED and the protocol is set to HTTP, HTTPS, HTTP2 or H2C.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	OutlierDetection *OutlierDetectionParameters `json:"outlierDetection,omitempty" tf:"outlier_detection,omitempty"`

	// A named port on a backend instance group representing the port for
	// communication to the backend VMs in that group. Required when the
	// loadBalancingScheme is EXTERNAL, EXTERNAL_MANAGED, INTERNAL_MANAGED, or INTERNAL_SELF_MANAGED
	// and the backends are instance groups. The named port must be defined on each
	// backend instance group. This parameter has no meaning if the backends are NEGs. API sets a
	// default of "http" if not given.
	// Must be omitted when the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
	// +kubebuilder:validation:Optional
	PortName *string `json:"portName,omitempty" tf:"port_name,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// is set to HTTP, HTTPS, HTTP2 or H2C
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The Region in which the created backend service should reside.
	// If it is not provided, the provider region is used.
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// The security policy associated with this backend service.
	// +kubebuilder:validation:Optional
	SecurityPolicy *string `json:"securityPolicy,omitempty" tf:"security_policy,omitempty"`

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE, CLIENT_IP_NO_DESTINATION, STRONG_COOKIE_AFFINITY.
	// +kubebuilder:validation:Optional
	SessionAffinity *string `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// Describes the HTTP cookie used for stateful session affinity. This field is applicable and required if the sessionAffinity is set to STRONG_COOKIE_AFFINITY.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	StrongSessionAffinityCookie *StrongSessionAffinityCookieParameters `json:"strongSessionAffinityCookie,omitempty" tf:"strong_session_affinity_cookie,omitempty"`

	// Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing and Internal HTTP(S) load balancing.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Subsetting *SubsettingParameters `json:"subsetting,omitempty" tf:"subsetting,omitempty"`

	// The backend service timeout has a different meaning depending on the type of load balancer.
	// For more information see, Backend service settings.
	// The default is 30 seconds.
	// The full range of timeout values allowed goes from 1 through 2,147,483,647 seconds.
	// +kubebuilder:validation:Optional
	TimeoutSec *float64 `json:"timeoutSec,omitempty" tf:"timeout_sec,omitempty"`
}

type StrongSessionAffinityCookieInitParameters struct {

	// Name of the cookie.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to set for the cookie.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Lifetime of the cookie.
	// Structure is documented below.
	TTL *StrongSessionAffinityCookieTTLInitParameters `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type StrongSessionAffinityCookieObservation struct {

	// Name of the cookie.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to set for the cookie.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Lifetime of the cookie.
	// Structure is documented below.
	TTL *StrongSessionAffinityCookieTTLObservation `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type StrongSessionAffinityCookieParameters struct {

	// Name of the cookie.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to set for the cookie.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Lifetime of the cookie.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	TTL *StrongSessionAffinityCookieTTLParameters `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type StrongSessionAffinityCookieTTLInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type StrongSessionAffinityCookieTTLObservation struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type StrongSessionAffinityCookieTTLParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds" tf:"seconds,omitempty"`
}

type SubsettingInitParameters struct {

	// The algorithm used for subsetting.
	// Possible values are: CONSISTENT_HASH_SUBSETTING.
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`

	// The number of backends per backend group assigned to each proxy instance or each service mesh client.
	// An input parameter to the CONSISTENT_HASH_SUBSETTING algorithm. Can only be set if policy is set to
	// CONSISTENT_HASH_SUBSETTING. Can only be set if load balancing scheme is INTERNAL_MANAGED or INTERNAL_SELF_MANAGED.
	// subsetSize is optional for Internal HTTP(S) load balancing and required for Traffic Director.
	// If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number
	// of proxies/clients visible to each backend and vice versa.
	// Must be greater than 0. If subsetSize is larger than the number of backends/endpoints, then subsetting is disabled.
	SubsetSize *float64 `json:"subsetSize,omitempty" tf:"subset_size,omitempty"`
}

type SubsettingObservation struct {

	// The algorithm used for subsetting.
	// Possible values are: CONSISTENT_HASH_SUBSETTING.
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`

	// The number of backends per backend group assigned to each proxy instance or each service mesh client.
	// An input parameter to the CONSISTENT_HASH_SUBSETTING algorithm. Can only be set if policy is set to
	// CONSISTENT_HASH_SUBSETTING. Can only be set if load balancing scheme is INTERNAL_MANAGED or INTERNAL_SELF_MANAGED.
	// subsetSize is optional for Internal HTTP(S) load balancing and required for Traffic Director.
	// If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number
	// of proxies/clients visible to each backend and vice versa.
	// Must be greater than 0. If subsetSize is larger than the number of backends/endpoints, then subsetting is disabled.
	SubsetSize *float64 `json:"subsetSize,omitempty" tf:"subset_size,omitempty"`
}

type SubsettingParameters struct {

	// The algorithm used for subsetting.
	// Possible values are: CONSISTENT_HASH_SUBSETTING.
	// +kubebuilder:validation:Optional
	Policy *string `json:"policy" tf:"policy,omitempty"`

	// The number of backends per backend group assigned to each proxy instance or each service mesh client.
	// An input parameter to the CONSISTENT_HASH_SUBSETTING algorithm. Can only be set if policy is set to
	// CONSISTENT_HASH_SUBSETTING. Can only be set if load balancing scheme is INTERNAL_MANAGED or INTERNAL_SELF_MANAGED.
	// subsetSize is optional for Internal HTTP(S) load balancing and required for Traffic Director.
	// If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number
	// of proxies/clients visible to each backend and vice versa.
	// Must be greater than 0. If subsetSize is larger than the number of backends/endpoints, then subsetting is disabled.
	// +kubebuilder:validation:Optional
	SubsetSize *float64 `json:"subsetSize,omitempty" tf:"subset_size,omitempty"`
}

type TTLInitParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type TTLObservation struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`
}

type TTLParameters struct {

	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds" tf:"seconds,omitempty"`
}

// RegionBackendServiceSpec defines the desired state of RegionBackendService
type RegionBackendServiceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RegionBackendServiceParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider RegionBackendServiceInitParameters `json:"initProvider,omitempty"`
}

// RegionBackendServiceStatus defines the observed state of RegionBackendService.
type RegionBackendServiceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RegionBackendServiceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// RegionBackendService is the Schema for the RegionBackendServices API. A Region Backend Service defines a regionally-scoped group of virtual machines that will serve traffic for load balancing.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp-beta}
type RegionBackendService struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RegionBackendServiceSpec   `json:"spec"`
	Status            RegionBackendServiceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RegionBackendServiceList contains a list of RegionBackendServices
type RegionBackendServiceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RegionBackendService `json:"items"`
}

// Repository type metadata.
var (
	RegionBackendService_Kind             = "RegionBackendService"
	RegionBackendService_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: RegionBackendService_Kind}.String()
	RegionBackendService_KindAPIVersion   = RegionBackendService_Kind + "." + CRDGroupVersion.String()
	RegionBackendService_GroupVersionKind = CRDGroupVersion.WithKind(RegionBackendService_Kind)
)

func init() {
	SchemeBuilder.Register(&RegionBackendService{}, &RegionBackendServiceList{})
}
